[{"content":" Context 是Go语言于v1.7引入，用于在goroutine中传递截止时间、取消信号和其他请求范围值的标准库，也是Go语言的一个特殊机制.\n为什么需要 Context ？ 在经典的网络服务器中，每个传入的请求都在一个单独的goroutine中处理，这里处理过程可能涉及到多个下游调用，例如访问数据库、调用 RPC 服务等，这时会面临几个问题：\n请求取消：如果客户端连接关闭或者请求超时，那么需要关闭所有相关的 goroutine ，避免资源浪费. 超时控制：某些操作需要明确的执行时间，超过该时间该停止，并返回超时错误. 数据传递：在整个请求链中，共享一些数据（例如：user_id, trace_id\u0026hellip;），需要一种安全的方式将共享的数据传递到各个函数，同时不污染函数签名. context.Context 正是为了优雅解决这些问题，提供了一个在 API 边界之间和 goroutine 之间传递“元数据”的标准方式.\nContext 的核心原理 Context 接口 context 包的核心是 Context 接口，它定义了四个方法：\ntype Context interface { // Deadline 返回一个时间点，当到达该时间点后，Context 将被自动取消。 // 如果没有设置 Deadline，ok 将返回 false。 Deadline() (deadline time.Time, ok bool) // Done 返回一个 channel。当 Context 被取消或超时时，该 channel 会被关闭。 // 如果 Context 不可取消，Done() 可能返回 nil。 Done() \u0026lt;-chan struct{} // Err 在 Done() channel 关闭后，返回 Context 被取消的原因。 // 如果 Context 未被取消，返回 nil。 // 常见原因为 context.Canceled 和 context.DeadlineExceeded。 Err() error // Value 返回与该 Context 关联的键（key）对应的值（value）。 // 主要用于在请求处理链中传递请求范围的数据。 Value(key any) any } Context 树状结构和传播机制 Go 中的 Context 具有继承关系，可以形成一棵树状结构。当你基于一个父 Context 创建一个子 Context 时，它们之间就建立了关联.\n这种结构的核心特性是取消信号的单向传播：\n当一个父 Context 被取消时，所有由它派生出的子 Context 也会被立即取消\n这个机制是 context 实现优雅取消和超时控制的关键。例如，一个代表 HTTP 请求的 Context 如果因为客户端断开连接而被取消，那么由它派生出的、用于数据库查询和 RPC 调用的子 Context 也会随之取消，从而中断这些下游操作.\nContext 的使用 context 包提供了几种创建和派生 Context 的方法.\n顶层(空) Context context 包提供了两个顶层的、空的 Context，它们是所有 Context 树的根节点：\ncontext.Background(): 通常用于主函数、初始化和测试代码中，作为最顶层的 Context。它永远不会被取消。 context.TODO(): 当你不清楚应该使用哪个 Context，或者当前函数未来可能会更新以接收 Context 时，可以使用它。它本质上和 Background() 一样。 可取消 Context 有三种主要方式可以创建可被取消的子 Context：\ncontext.WithCancel(parent Context) (ctx Context, cancel CancelFunc)\nWithCancel 返回一个派生的 ctx 和一个 cancel 函数。当 cancel 函数被调用时，ctx 及其所有子 Context 都会被取消\n// 假设我们启动一个长时间运行的后台任务，并希望能在需要时手动停止它。 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func worker(ctx context.Context, name string) { for { select { case \u0026lt;-ctx.Done(): // 监听取消信号 fmt.Printf(\u0026#34;%s: worker cancelled\\n\u0026#34;, name) return default: fmt.Printf(\u0026#34;%s: working...\\n\u0026#34;, name) time.Sleep(1 * time.Second) } } } func main() { // 创建一个可取消的 context ctx, cancel := context.WithCancel(context.Background()) go worker(ctx, \u0026#34;Worker 1\u0026#34;) go worker(ctx, \u0026#34;Worker 2\u0026#34;) // 运行 3 秒后发出取消信号 time.Sleep(3 * time.Second) fmt.Println(\u0026#34;Main: sending cancellation signal\u0026#34;) cancel() // 调用 cancel 函数 // 等待一小段时间，确保 worker 有时间退出 time.Sleep(1 * time.Second) fmt.Println(\u0026#34;Main: finished\u0026#34;) } 在这个例子中，worker goroutine 通过 select 语句监听 ctx.Done()。一旦 main 函数调用 cancel()，ctx.Done() 的 channel 会被关闭，worker 就能收到信号并优雅退出。\ncontext.WithDeadline(parent Context, d time.Time) (Context, CancelFunc)\nWithDeadline 设置了一个具体的截止时间点。当系统时间到达或超过这个时间点时，Context 会被自动取消。\ncontext.WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)\nWithTimeout 是 WithDeadline 的一个常用封装。它设置一个从当前时间开始的超时时长。当超时后，Context 会被自动取消。\ntips：无论是 WithCancel、WithDeadline 还是 WithTimeout，都应该总是使用 defer cancel() 来确保在函数返回时释放与 Context 相关的资源，即使操作成功完成\n// 在处理外部 API 请求时，设置超时是非常重要的，可以防止服务因下游依赖的缓慢而卡死。 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 模拟一个耗时的 API 调用 func thirdPartyAPICall(ctx context.Context) (string, error) { select { case \u0026lt;-time.After(5 * time.Second): // 模拟 API 调用需要 5 秒 return \u0026#34;API response\u0026#34;, nil case \u0026lt;-ctx.Done(): // 监听超时或取消 return \u0026#34;\u0026#34;, ctx.Err() // 返回 context 的错误信息 } } func main() { // 创建一个 3 秒超时的 context ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() // 确保 cancel 被调用 fmt.Println(\u0026#34;Making API call...\u0026#34;) result, err := thirdPartyAPICall(ctx) if err != nil { fmt.Printf(\u0026#34;API call failed: %v\\n\u0026#34;, err) // 输出: API call failed: context deadline exceeded } else { fmt.Printf(\u0026#34;API call successful: %s\\n\u0026#34;, result) } } 在这个例子中，thirdPartyAPICall 需要 5 秒才能完成，但我们的 Context 设置了 3 秒的超时。因此，在 3 秒后，ctx.Done() 会被关闭，函数将返回 context.DeadlineExceeded 错误\n传递值 Context context.WithValue(parent Context, key, val any) Context\nWithValue 可以将一个键值对附加到 Context 上，并返回一个新的 Context。获取值时，使用 ctx.Value(key)。 最佳实践：\n不要使用内置类型作为键：为了避免键冲突，应该使用自定义的、不可导出的类型作为 Context 的键。 只传递请求范围的数据：Context 的 Value 只应该用于传递贯穿整个请求处理链路的数据，例如用户认证信息、追踪 ID 等。不应该用它来传递可选参数。 // 传递追踪 ID (Trace ID) 在微服务架构中，为了方便日志追踪和故障排查， // 通常会为每个请求生成一个唯一的追踪 ID，并将其在所有服务调用中传递 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; ) // 定义一个不可导出的自定义类型作为 key type traceIDKey string const key traceIDKey = \u0026#34;traceID\u0026#34; func processRequest(ctx context.Context) { // 从 context 中获取 traceID traceID, ok := ctx.Value(key).(string) if !ok { traceID = \u0026#34;unknown\u0026#34; } fmt.Printf(\u0026#34;Processing request with Trace ID: %s\\n\u0026#34;, traceID) logSomething(ctx, \u0026#34;Starting database query...\u0026#34;) } func logSomething(ctx context.Context, message string) { traceID, ok := ctx.Value(key).(string) if !ok { traceID = \u0026#34;unknown\u0026#34; } fmt.Printf(\u0026#34;[Log - Trace ID: %s] %s\\n\u0026#34;, traceID, message) } func main() { // 假设这是请求的入口，我们生成一个 traceID 并存入 context ctx := context.WithValue(context.Background(), key, \u0026#34;xyz-123-abc\u0026#34;) processRequest(ctx) } Context 最佳实践 Context 作为函数第一个参数：按照惯例，如果函数需要接受 Context，应该将其作为第一个参数，通常命名为 ctx。\nfunc DoSomething(ctx context.Context, arg1 string, arg2 int) error { ... } 不要将 Context 存储在结构体中：应该显式地在函数间传递 Context。将其存储在结构体中会使其生命周期变得不明确。\nContext 是线程安全的：可以放心地在多个 goroutine 中同时使用同一个 Context。\n只传递真正必要的数据：WithValue 很方便，但也容易被滥用。只用它来传递那些必须贯穿整个调用链的请求范围数据。\n空 Context 不应为 nil：即使一个函数允许，也不要传递一个 nil 的 Context。如果你不确定用什么，就使用 context.TODO()。\n总结 context 是 Go 并发编程模型中不可或缺的一部分。它通过简洁的接口和强大的树状传播机制，为处理并发操作的取消、超时和数据传递提供了标准化的解决方案。深刻理解其原理并遵循最佳实践，将帮助你编写出更健壮、更可靠、更易于维护的 Go 程序\n推荐阅读 context.go Go Concurrency Patterns: Context Contexts and structs How to Use Context in Golang (Deadlines, Cancellation, and Passing Values) ","date":"2025-09-15","id":0,"permalink":"/posts/golang/context/","summary":"Context 是Go语言于v1.7引入，用于在goroutine中传递截止时间、取消信号和其他请求范围值的标准库，也是Go语言的一个特殊机制.","tags":"golang context","title":"Golang/Context"},{"content":" 该页面主要收集一些好用的资源，包括但不限于：学习资料、工具以及开源项目等.\n目录 Programming Language Learning Website Github Repository Tool Markdown :Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”. roadmap.sh :roadmap.sh is a community effort to create roadmaps, guides and other educational content to help guide developers in picking up a path and guide their learnings. Programming Language Learning Effective Go :Effective Go 是 Go 语言的官方文档，它包含了 Go 语言的基础知识、编码规范、性能优化技巧等. Go语言设计与实现 :详细解释Go语言的编译原理、运行时、基础知识和进阶知识. Go/tonybai :Go语言博客，由Tony Bai创作. Go/aceid - 轻量级并发服务框架zinx :通过Zinx框架来了解基于Golang编写一个TCP服务器的整体轮廓 MDN Web Docs :MDN Web Docs 是 Mozilla 开发的一个免费的、开放的、跨平台的 Web 文档项目，它包含了 Web 技术的所有文档，包括 HTML、CSS、JavaScript 等. Rust/trpl-zh-cn :The Rust Programming Language 中文翻译. Website hugo :Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. uiverse :The Largest Library of Open-Source UI Github Repository github/build-your-owm-x :This repository is a compilation of well-written, step-by-step guides for re-creating our favorite technologies from scratch. Tool eyedropper :eyedropper是一个颜色选择器，单击颜色吸管按钮并在屏幕上的任意位置选择一种颜色. convertio :convertio是一个免费的文件转换工具，支持多种文件格式之间的转换，如PDF、图片、视频、音频等。 ","date":"2025-05-13","id":1,"permalink":"/recommand/","summary":"该页面主要收集一些好用的资源，包括但不限于：学习资料、工具以及开源项目等.","tags":"recommand","title":"Recommand Resource"}]